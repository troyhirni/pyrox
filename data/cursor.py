"""
Copyright 2017 Troy Hirni
This file is part of the pyro project, distributed under the terms 
of the GNU Affero General Public License.

CURSOR - Generators or iteration through data of various types.
         Requires: python 2.2+

Cursor objects are for one-time use to navigate a various types of
(hopefully any kind of) data. They're intended for internal use, in
support of various other data package modules, but could be useful if
you want a generator for data that comes in a variety of objects.

for item in cursor.Cursor([[1,2,3], [4,5,6]]).gen:
	print (item.v)


* THIS IS UNDER CONSTRUCTION - VERY EARLY DEVELOPMENT - UNRELIABLE! *

"""

from .. import *




class CursorParam(object):
	"""
	CursorParam methods manipulate data of various types, mostly list,
	dict, and string. All methods work with either self.v, or in some
	cases, an optional argument to use instead of self.v.
	
	The self.v property must be set directly by generator before it is
	returned or tested by a `where` callback. (See the CursorGenerators
	class.)
	.
	"""
	def __init__(self):
		self.v = None
	


#
# CURSOR
#
class Cursor(object):
	"""
	Cursor objects are for one-time iteration through a list, dict, 
	iterators, generators, text or file streams (line by line), or even
	just a single values such as int, float, whatever... (hopefully, at
	least eventually) any kind of data. Cursor will select the correct
	generator to match the data.
	
	Use fetch() or fetchall() to return one or all of the data. Use the
	generator() classmethod to get the generator of an unknown type.
	Call any of the individual gen-prefixed functions directly if you 
	know your object type or, if you prefer, pass a keyword value whose
	key specifies the generator you want (and value specifying the key
	object) to the Cursor constructor (instead of data)
	"""
	
	def __init__(self, data=None, **k):
		"""
		Pass either the data to iterate (as `data` argument) or a keyword.
		argument `gen` that generates each value to iterate through.
		
		A custom Param object may be specified using the kwarg `param`. 
		If unspecified, cursor.CursorParam will be used. Regardless, the 
		same cursor is passed to each including values whose members are 
		"reiterated" using another cursor generated by the param. 
		
		FETCH:
		After creating a generator, this constructor sets self.fetch the 
		generator's `next` method in python 2, or it's `__next__` method
		in python 3. This is done to provide a .fetch() method with the
		greatest possible speed (for iteration through huge datasets).
		
		Example:
		c = cursor.Cursor([1,2,3])
		c.fetch() # returns the next item (or raises StopIteration)
		"""
		
		# get optional param object
		self.__param = k.get('param', CursorParam())
		
		# get the where method
		self.__where = k.get('where')
		
		# where must be callable
		if self.__where and (not callable(self.__where)):
			raise Exception('cursor-create-fail', 
				xdata(reason='where-not-callable')
			)
		
		# create the correct generator for the given data
		self.__gen = k.get('gen', self.generator(data, **k))
		
		# steal the generator's 'next' method
		try:
			self.fetch = self.__gen.__next__
		except:
			# for python 2
			self.fetch = self.__gen.next
	
	
	@property
	def gen(self):
		return self.__gen
	
	
	
	def gentype(self, x=None, **k):
		"""
		Return a generator suitable to the type and/or attributes of the
		argument object `x`.
		"""
		# if it's already a generator, return it
		if (type(x).__name__ == 'generator'):
			return x
		
		# list, dict, and string will probably be the most common types
		# when recursing; unfortunately, they have to come in the wrong
		# order; Maybe I can find a way to improve speed here.
		try:
			x.keys
			x.__getitem__
			return self.genmap
		except AttributeError:
			pass
		
		# make sure a string isn't thrown in with list, tupel, etc...
		if isinstance(x, basestring):
			return self.genval
		
		# any sequence that doesn't have keys
		try:
			x.__getitem__
			return self.genseq
		except AttributeError:
			pass
		
		try:
			if x == x.__iter__():
				return self.geniter
		except Exception:
			pass
		
		# text input (via file, url, or string) will probably be the most
		# common *FIRST* thing to be cursored over, then yielding a list
		# to parse; in such cases, though, the list is probably a list of
		# lists or dicts which will need to be "recursed", so it might be
		# best file or string io is lower in the list
		try:
			x.readline
			x.tell
			return self.genlines
		except AttributeError:
			pass
		
		# uncomment to debug
		#return type(x)
		
		# if all else fails...
		return self.genval
	
	
	
	def generator(self, data=None, **k):
		"""
		The generator classmethod returns the cursor module generator 
		best-suited to the type of data you pass it. 
		"""
		if k and ('gen' in k):
			return k['gen']
		
		else:
			gen = self.gentype(data, **k)
			return gen(data)

	
	
	def genseq(self, x):
		"""
		Yields each item for list (or list-like object) `x`.
		"""
		param = self.__param
		where = self.__where
		if where:
			if param:
				for v in x:
					param.v = v
					if where(param):
						yield param
			else:
				for v in x:
					if where(v):
						yield v
		else:
			if param:
				for v in x:
					param.v = v
					yield param
			else:
				for v in x:
					yield v
			
		
	def genmap(self, x):
		"""Yields each key for dict (or dict-like object) `x`."""
		param = self.__param
		where = self.__where
		if where:
			if param:
				for key in x:
					param.v = x[key]
					if where(param):
						yield param
			else:
				for key in x: 
					if where(x[key]):
						yield x[key]
		else:
			if param:
				for key in x:
					param.v = x[key]
					yield param
			else:
				for key in x[key]:
					yield x[key]
	
		
	def genlines(self, x):
		"""Yields lines for stream object `x`."""
		param = self.__param
		where = self.__where
		if where:
			if param:
				for line in x:
					param.v = line
					if where(param):
						yield param
			else:
				for line in x:
					if where(line):
						yield line
		else:
			if param:
				for line in x:
					param.v = line
					yield param
			else:
				for line in x:
					yield line
	
	
	def geniter(self, x):
		"""
		Yields the next item for iterator.
		"""
		param = self.__param
		where = self.__where
		if where:
			if param:
				for v in x:
					param.v = v
					if where(param):
						yield param
			else:
				for v in x:
					if where(v):
						yield v
		else:
			if param:
				for v in x:
					param.v = v
					yield param
			else:
				for v in x:
					yield v
