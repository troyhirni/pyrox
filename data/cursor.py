"""
Copyright 2017 Troy Hirni
This file is part of the pyro project, distributed under the terms 
of the GNU Affero General Public License.

CURSOR - Generators or iteration through data of various types.
         Requires: python 2.2+

Cursor objects are for one-time use to navigate a various types of
(hopefully any kind of) data. They're intended for internal use, in
support of various other data package modules, but could be useful if
you want a generator for data that comes in a variety of objects.

for item in cursor.Cursor([[1,2,3], [4,5,6]]).gen:
	print (item.v)


* UNDER CONSTRUCTION - VERY EARLY DEVELOPMENT - UNRELIABLE *

# FAILS...
d={'a':1,'b':9,'c':['food!']}
reload(cursor).TEST(d, use=lambda p: p.v==['food'])

"""

from .param import *



#
# CURSOR
#
class Cursor(object):
	"""
	Cursor objects are for one-time iteration through a list, dict, 
	iterators, generators, text or file streams (line by line), or even
	just a single values such as int, float, whatever... (hopefully, at
	least eventually) any kind of data. Cursor will select the correct
	generator to match the data.
	
	Use fetch() or fetchall() to return one or all of the data. Use the
	generator() classmethod to get the generator of an unknown type.
	Call any of the individual gen-prefixed functions directly if you 
	know your object type or, if you prefer, pass a keyword value whose
	key specifies the generator you want (and value specifying the key
	object) to the Cursor constructor (instead of data)
	"""
	
	def __init__(self, data=None, **k):
		"""
		Pass either the data to iterate (as `data` argument) or a keyword.
		argument `gen` that generates each value to iterate through.
		
		Optional keyword argument `use` may specify a callback function
		that can serve to alter the param and determine whether it should
		be included in the resulting dataset. The `use` callable is 
		applied to each data item read by the cursor generator; if False
		is returned, the item is ignored and the cursor moves on to test
		the next item. Data items are yielded only when `use` returns
		True.
		
		A custom Param object may be specified using the kwarg `param`. 
		If unspecified, data.param.Param will be used. Regardless, the 
		same cursor is passed to each including values whose members are 
		"reiterated" using another cursor generated by the param. 
		
		[REM: Check that the above is implemented.]
		
		FETCH:
		After creating a generator, this constructor sets self.fetch the 
		generator's `next` method in python 2, or its `__next__` method
		in python 3. This is done to provide a .fetch() method with the
		greatest possible speed (for iteration through huge datasets).
		
		Example:
		c = cursor.Cursor([1,2,3])
		c.fetch()   # returns the next `param` item
		c.fetch().v # returns the next param item's value `v`
		"""
		
		# get optional param object
		self.__param = k.get('param', Param())
		
		# get the use method
		self.__use = k.get('use')
		
		# use must be callable
		if self.__use and (not callable(self.__use)):
			raise Exception('cursor-create-fail', 
				xdata(reason='callback-not-callable', callback='use')
			)
		
		# create the correct generator for the given data
		self.__gen = k.get('gen', self.generator(data, **k))
		
		# steal the generator's 'next' method
		try:
			self.fetch = self.__gen.__next__ # python 3
		except:
			self.fetch = self.__gen.next # python 2
	
	
	def __call__(self, fn):
		
		# REM: Do not pass self.__gen as a keyword argument or it will
		#      use exactly that generator, which belongs to self, not
		#      to the new Cursor being created here. Passing it as gen=
		#      will just yeild exactly the results this (self) would.
		#      By passing it as the data, the generator will (or should)
		#      create a new generator that honors the new `use` lambda.
		return Cursor(self.__gen, use=fn)
	
	
	def __iter__(self):
		return self.gen
	
	
	@property
	def gen(self):
		return self.__gen
	
	
	def fetch(self):
		"""
		Return a Param object representing the next matching row. Use
		Param.v to get the value, Param.i to get the index, offset, or
		key.
		
		NOTE: This method is replaced in the constructor; it is set to
		      the generator's __next__ method (or it's .next() method, if
		      python 2).
		"""
		pass # replaced in constructor
	
	
	def fetchall(self):
		"""
		Returns a list of all Param objects generated by this cursor.
		"""
		return [p for p in self.__gen]
	
	
	def values(self):
		"""
		Return a list of values (the value of each generated Param).
		This could be a list of lists, dict, string, or even complex 
		objects - it's the final result of all processing.
		"""
		return [p.v for p in self.__gen]
	
	
	def gentype(self, x=None, **k):
		"""
		Return a generator suitable to the type and/or attributes of the
		argument object `x`.
		
		NOTE: This method uses type and various combinations of object
		      attributes to try to determine which generator to use; it
		      may take a while before I can work out all the kinks.
		"""
		
		# DEBUGGING!
		#print (type(x).__name__)
		
		# if it's already a generator, return it
		if (type(x).__name__ == 'generator'):
			return self.gengen
		
		# text input (via file, url, or string) will probably be the most
		# common *FIRST* thing to be cursored over, then yielding a list
		# to parse; in such cases, though, the list is probably a list of
		# lists or dicts which will need to be "recursed", so it might be
		# best file or string io is lower in the list
		try:
			x.readline
			return self.genlines
		except AttributeError:
			# this object does not have .readline()
			pass
		
		# list, dict, and string will probably be the most common types
		# when recursing; unfortunately, they have to come in the wrong
		# order; Maybe I can find a way to improve speed here.
		try:
			x.keys
			x.__getitem__
			return self.genmap
		except AttributeError:
			pass
		
		# make sure a string isn't thrown in with list, tupel, etc...
		if isinstance(x, basestring):
			return self.genval
		
		# any sequence that doesn't have keys
		# REM: MUST come after dict
		try:
			x.__getitem__
			return self.genseq
		except AttributeError:
			pass
		
		try:
			if x == x.__iter__():
				return self.geniter
		except Exception:
			pass
		
		# uncomment to debug
		#return type(x)
		
		# if all else fails...
		return self.genval
	
	
	def generator(self, data=None, **k):
		"""
		The generator method returns the cursor module generator 
		best-suited to the type of data you pass it. 
		"""
		if 'gen' in k:
			return k['gen']
		
		gen = self.gentype(data, **k)
		return gen(data)
	
	
	def gengen(self, x):
		param = self.__param
		use = self.__use
		for p in x:
			if use:
				for i,v in enumerate(x):
					param.v = v.v
					param.i = i
					if use(param):
						yield param
			else:
				for i,v in enumerate(x):
					param.v = v.v
					param.i = i
					yield param
			
	
	def genval(self, x):
		p = self.__param
		p.v = x
		p.i = None
		if not use:
			yield p
		elif use(p):
			yield p
		
	
	def genseq(self, x):
		"""
		Yields each item for list (or list-like object) `x`.
		"""
		param = self.__param
		use = self.__use
		if use:
			for i,v in enumerate(x):
				param.v = v
				param.i = i
				if use(param):
					yield param
		else:
			for i,v in enumerate(x):
				param.v = v
				param.i = i
				yield param
			
		
	def genmap(self, x):
		"""Yields each key for dict (or dict-like object) `x`."""
		param = self.__param
		use = self.__use
		if use:
			for i,v in enumerate(x):
				param.i = v
				param.v = x[v]
				if use(param):
					yield param
		else:
			for i,v in enumerate(x):
				param.i = v
				param.v = x[v]
				yield param
	
		
	def genlines(self, x):
		"""Yields lines for stream object `x`."""
		param = self.__param
		use = self.__use
		i = 0
		if use:
			for line in x:
				param.v = line
				param.i = i
				i += 1
				if use(param):
					yield param
		else:
			for line in x:
				param.v = line
				param.i = i
				i += 1
				yield param
	
	
	def geniter(self, x):
		"""
		Yields the next item for iterator.
		"""
		param = self.__param
		use = self.__use
		i = 0
		if use:
			for v in x:
				param.v = v
				param.i = i
				i += 1
				if use(param):
					yield param
		else:
			for v in x:
				param.v = v
				param.i = i
				i += 1
				yield param


