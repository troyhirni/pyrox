"""
Copyright 2014-2017 Troy Hirni
This file is part of the pyrox project, distributed under
the terms of the GNU Affero General Public License.

TRANSFORM FILE - File Object, for structured text file io.


THIS IS - HOPEFULLY - THE NEXT VERSION OF TFILE; It's not clear yet
whether the classes defined here can be made to work correctly, but
I want it backed up online in case my flaky computer dies before it
wakes.


Use TransformFile objects to read text files which describe objects
that can be transformed from data to text or from text to data by a 
data.transform.Transform object.

Here are some examples of use:

# EXAMPLE 1 - FILE I/O
from px.data import transform
from pyrox.fs import tfile
f = tfile.TransformFile(transform.TransformJson(), 'test.json')
w = f.writer()
w.write([1,2,3,4,5])
r = f.reader()
r.read()

# EXAMPLE 2 - STREAM I/0
b = tfile.Buffer()
w = f.writer(stream=b)
w.write(dict(a=1,b=9))
r = f.reader(stream=b.reader())
r.read()
"""


from .file import *


class TransformFile (File):
	"""
	Use TransformFile objects to read text files which describe objects
	that can be transformed from data to text or from text to data by a
	data.transform.Transform object.
	
	The first argument to TransformFile must be a data.transform object
	to convert the file's text to a python object. Additional arguments
	are those required by the File constructor.
	
		from px.fs import file
		from px.data import transform
		
		jsonTran = data.transform.TransformJson()
		jsonfile = file.TransformFile(jsonTran, 'test/test.json')
		jsonfile.write(dict(value1="That's valuable!", ix=9))
	"""
	
	def __init__(self, transformer, *a, **k):
		self.__transform = transformer
		File.__init__(self, *a, **k)
	
	
	# READ
	def read(self, *a, **k):
		"""
		The read() method's results are transformed using the transformer
		passed to the constructor. For example, if JSON text describes a
		dict, the TransformJson transformer will convert it to a dict and
		return that dict.
		"""
		return self.__transform.fromtext(File.read(self, *a, **k))
	
	
	# WRITE
	def write(self, data, *a, **k):
		"""
		Pass data as expected by this file's transformer. For example, 
		if the TransformJson transformer was specified to the constructor
		then you can pass string, dict, list, or any object parsable by
		the json.dumps() method and that will be transformed to text then
		written to this file.
		"""
		File.write(self, self.__transform.totext(data), *a, **k)
	
	
	# READER
	def reader(self, **k):
		try:
			return TransformReader(k.pop('stream'), self.__transform, **k)
		except KeyError:
			k.setdefault('mode', 'r')
			ek = self.extractEncoding(k) if 'b' in k['mode'] else {}
			return TransformReader(self.open(**k), self.__transform, **ek)
		
	
	# WRITER
	def writer(self, **k):
		try:
			# if stream is given, send kwargs directly to Writer()
			return TransformWriter(k.pop('stream'), self.__transform, **k)
		except KeyError:
			# ...else get stream from self.open()
			k.setdefault('mode', 'w')
			ek = self.extractEncoding(k) if 'b' in k['mode'] else {}
			return TransformWriter(self.open(**k), self.__transform, **ek)





class TransformStream(Stream):
	pass





class TransformReader(TransformStream):
	"""
	TransformReader reads and returns an object described by the entire
	stream's contents regardless of which reading method is called.
	Subsequent read attempts will give the same result as any stream
	being read after the end of file: '' for readline(), StopIteration 
	for next(), etc...
	"""
	def __init__(self, stream, transformer, **k):
		self.__transform = transformer
		
		# In some cases, Reader may alter its methods, so we'll separate
		# it from this object but still use its methods.
		self.__reader = Reader(stream, **k)
		
		# p2/p3
		self.next = self.__next__
		self.readline = self.read
	
	
	def __iter__(self):
		"""Line iterator."""
		return self.lines
	
	def __next__(self):
		"""Read and return the next line."""
		return next(self.lines)
	
	
	@property
	def lines(self):
		"""
		Yeilds one result - an object described by the full text of this
		stream.
		"""
		yield self.read()
	
	
	def read(self, *a):
		"""
		Returns an object generated by the `transformer` given to the 
		constructor using the full text of the stream given to the 
		constructor.
		
		All read-related methods are generated by this method.
		"""
		return self.__transform.fromtext(self.__reader.read())





class TransformWriter(TransformStream):
	"""
	Write to TransformWriter one time, passing an object to convert to
	a text representation of itself and then written to the stream
	given to the constructor.
	"""
	def __init__(self, stream, transformer, **k):
		"""
		Pass the `stream` to receive the text and a `transformer` object
		to translate any given object to text.
		"""
		self.__transform = transformer
		self.__target = Writer(stream, **k)
		self.writelines = self.write
	
	def write(self, data):
		"""
		Write the object to the stream. Subsequent write attempts raise
		an exception.
		
		#
		# FAILS IN PYTHON 2
		#  - needs one of those things like in csv to make it work with
		#    bytes in p2, unicode in p3
		#
		"""
		self.__target.write(self.__transform.totext(data))
		self.__target.flush()
		self.write = self.__writeeof
	
	def __writeeof(self, *a):
		raise EOFError()


